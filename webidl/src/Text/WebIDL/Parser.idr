module Text.WebIDL.Parser

import Data.Refined
import Data.List.Elem
import Text.Parse.Manual
import Text.WebIDL.Types
import Text.WebIDL.Lexer

%default total

--------------------------------------------------------------------------------
--          Arguments
--------------------------------------------------------------------------------

-- optArgList : IdlGrammar' ArgumentList
-- optArgList = inParens argumentList <|> pure (NoVarArg Nil Nil)
-- 
-- --------------------------------------------------------------------------------
-- --          Member
-- --------------------------------------------------------------------------------
-- 
-- member : List String -> IdlGrammar a -> IdlGrammar a
-- member [] g = g <* symbol ';'
-- member (h :: t) g = key h *> member t g
-- 
-- export
-- const : IdlGrammar Const
-- const = member ["const"]
--         [| MkConst constType ident (symbol '=' *> constValue) |]
-- 
-- special : IdlGrammar Special
-- special =   (key "getter"  $> Getter)
--         <|> (key "setter"  $> Setter)
--         <|> (key "deleter" $> Deleter)
-- 
-- opName : IdlGrammar OperationName
-- opName =   (key "includes" $> MkOpName "includes")
--        <|> map (\(MkIdent s) => MkOpName s) ident
-- 
-- regularOperation : IdlGrammar RegularOperation
-- regularOperation =
--   member []
--   [| MkOp (pure ()) idlType (optional opName) (inParens argumentList) |]
-- 
-- specialOperation : IdlGrammar SpecialOperation
-- specialOperation =
--   member []
--   [| MkOp special idlType (optional opName) (inParens argumentList) |]
-- 
-- export
-- operation : IdlGrammar Operation
-- operation = map specToOp specialOperation <|> map regToOp regularOperation
-- 
-- callbackInterfaceMember : IdlGrammar CallbackInterfaceMember
-- callbackInterfaceMember =   map (\v => inject v) const
--                         <|> map (\v => inject v) regularOperation
-- 
-- dictMember : IdlGrammar DictionaryMemberRest
-- dictMember = member ["required"] [| Required attributes idlType ident |]
--            <|> member [] [| Optional idlType ident defaultV |]
-- 
-- inheritance : IdlGrammar' Inheritance
-- inheritance = optional (symbol ':' *> ident)
-- 
-- attributeName : IdlGrammar AttributeName
-- attributeName =  withKey "AttributeNameKeyword"
--                    (map (MkAttributeName . value) . AttributeNameKeyword.refine)
--              <|> map (MkAttributeName . value) ident
-- 
-- readonly : IdlGrammar a -> IdlGrammar (Readonly a)
-- readonly g = key "readonly" *> map MkRO g
-- 
-- inherit : IdlGrammar a -> IdlGrammar (Inherit a)
-- inherit g = key "inherit" *> map MkI g
-- 
-- attribute : IdlGrammar Attribute
-- attribute = member ["attribute"]
--             [| MkAttribute attributes idlType attributeName |]
-- 
-- stringifier : IdlGrammar Stringifier
-- stringifier =   key "stringifier" *> (
--                 map (\v => inject v) attribute
--             <|> map (\v => inject v) (readonly attribute)
--             <|> map (\v => inject v) regularOperation
--             <|> map (\v => inject v) (symbol ';')
--             )
-- 
-- static : IdlGrammar StaticMember
-- static =   key "static" *> (
--            map (\v => inject v) attribute
--        <|> map (\v => inject v) (readonly attribute)
--        <|> map (\v => inject v) regularOperation
--        )
-- 
-- maplike : IdlGrammar Maplike
-- maplike = member ["maplike"] $ inAngles [| MkMaplike (attributed idlType)
--                                         (symbol ',' *> attributed idlType) |]
-- 
-- setlike : IdlGrammar Setlike
-- setlike = member ["setlike"] $ inAngles [| MkSetlike (attributed idlType) |]
-- 
-- namespaceMember : IdlGrammar NamespaceMember
-- namespaceMember =   map (\v => inject v) regularOperation
--                 <|> map (\v => inject v) (readonly attribute)
-- 
-- constructor_ : IdlGrammar Constructor
-- constructor_ =
--   member ["constructor"] (map MkConstructor $ inParens argumentList)
-- 
-- partialInterfaceMember : IdlGrammar PartialInterfaceMember
-- partialInterfaceMember =
--       map IConst const
--   <|> map IOp operation
--   <|> map IAttr attribute
--   <|> map IAttrRO (readonly attribute)
--   <|> map IAttrInh (inherit attribute)
--   <|> map IMap maplike
--   <|> map IMapRO (readonly maplike)
--   <|> map ISet setlike
--   <|> map ISetRO (readonly setlike)
--   <|> map IStr stringifier
--   <|> map IStatic static
--   <|> member ["iterable"] (inAngles [| IIterable (attributed idlType)
--                                             optionalType |])
--   <|> member ["async","iterable"] (
--         do p  <- inAngles [| (,) (attributed idlType) optionalType |]
--            as <- optArgList
--            pure (IAsync (fst p) (snd p) as))
-- 
-- mixinMember : IdlGrammar MixinMember
-- mixinMember =   map MConst const
--             <|> map MOp regularOperation
--             <|> map MAttr attribute
--             <|> map MAttrRO (readonly attribute)
--             <|> map MStr stringifier
-- 
-- export
-- interfaceMember : IdlGrammar InterfaceMember
-- interfaceMember =   map (\v => inject v) constructor_
--                 <|> map (\v => inject v) partialInterfaceMember
-- 
-- members : IdlGrammar a -> IdlGrammar (List $ Attributed a)
-- members g = inBraces (many $ attributed g)
-- 
-- --------------------------------------------------------------------------------
-- --          Definition
-- --------------------------------------------------------------------------------
-- 
-- def :  (ss : List String)
--     -> {auto 0 prf : NonEmpty ss}
--     -> (IdlGrammar ExtAttributeList -> IdlGrammar a)
--     -> IdlGrammar a
-- def (s :: ss) g = g (run ss (attributes <* key s)) <* symbol ';'
--   where run : List String -> IdlGrammar x -> IdlGrammar x
--         run []        y = y
--         run (x :: xs) y = run xs (y <* key x)
-- 
-- def0 : (IdlGrammar' ExtAttributeList -> IdlGrammar a) -> IdlGrammar a
-- def0 g = g attributes <* symbol ';'
-- 
-- -- optional trailing comma
-- enumLits : IdlGrammar (List1 StringLit)
-- enumLits = sepList1 ',' stringLit <* (symbol ',' <|> pure ())
-- 
-- callback : IdlGrammar Callback
-- callback =
--   def ["callback"] $ \as =>
--   [| MkCallback as ident (symbol '=' *> idlType) (inParens argumentList) |]
-- 
-- callbackInterface : IdlGrammar CallbackInterface
-- callbackInterface =
--   def ["callback","interface"] $ \as =>
--   [| MkCallbackInterface as ident (members callbackInterfaceMember) |]
-- 
-- dictionary : IdlGrammar Dictionary
-- dictionary =
--   def ["dictionary"] $ \as =>
--   [| MkDictionary as ident inheritance (members dictMember) |]
-- 
-- enum : IdlGrammar Enum
-- enum = def ["enum"] $ \as => [| MkEnum as ident (inBraces enumLits) |]
-- 
-- iface : IdlGrammar Interface
-- iface =
--   def ["interface"] $ \as =>
--   [| MkInterface as ident inheritance (members interfaceMember) |]
-- 
-- includes : IdlGrammar Includes
-- includes =
--   def0 $ \as => [| MkIncludes as ident (key "includes" *> ident) |]
-- 
-- mixin : IdlGrammar Mixin
-- mixin = def ["interface","mixin"] $ \as =>
--         [| MkMixin as ident (members mixinMember) |]
-- 
-- nspace : IdlGrammar Namespace
-- nspace = def ["namespace"] $ \as =>
--          [| MkNamespace as ident (members namespaceMember) |]
-- 
-- pdictionary : IdlGrammar PDictionary
-- pdictionary = def ["partial","dictionary"] $ \as =>
--               [| MkPDictionary as ident (members dictMember) |]
-- 
-- pnamespace : IdlGrammar PNamespace
-- pnamespace = def ["partial","namespace"] $ \as =>
--              [| MkPNamespace as ident (members namespaceMember) |]
-- 
-- pmixin : IdlGrammar PMixin
-- pmixin = def ["partial","interface","mixin"] $ \as =>
--          [| MkPMixin as ident (members mixinMember) |]
-- 
-- pinterface : IdlGrammar PInterface
-- pinterface =
--   def ["partial","interface"] $ \as =>
--   [| MkPInterface as ident (members partialInterfaceMember) |]
-- 
-- typedef : IdlGrammar Typedef
-- typedef = def ["typedef"] $ \as =>
--           [| MkTypedef as attributes idlType ident |]
-- 
-- export
-- definition : IdlGrammar Definition
-- definition =
--       map (\v => inject v) callbackInterface
--   <|> map (\v => inject v) callback
--   <|> map (\v => inject v) dictionary
--   <|> map (\v => inject v) enum
--   <|> map (\v => inject v) iface
--   <|> map (\v => inject v) includes
--   <|> map (\v => inject v) mixin
--   <|> map (\v => inject v) nspace
--   <|> map (\v => inject v) typedef
-- 
-- export
-- part : IdlGrammar Part
-- part =   map (\v => inject v) pdictionary
--      <|> map (\v => inject v) pinterface
--      <|> map (\v => inject v) pmixin
--      <|> map (\v => inject v) pnamespace
-- 
-- 
-- export
-- partsAndDefs : IdlGrammar PartsAndDefs
-- partsAndDefs = accumNs . forget <$> some partOrDef
--   where partOrDef : IdlGrammar PartOrDef
--         partOrDef =   map Z part
--                   <|> map (S . Z) definition
-- 
-- --------------------------------------------------------------------------------
-- --          Parsing WebIDL
-- --------------------------------------------------------------------------------
-- 
-- toParseErr : ParsingError IdlToken -> Err
-- toParseErr (Error x Nothing)  = ParseErr x
-- toParseErr (Error x $ Just $ MkBounds startLine startCol _ _) =
--   ParseErrAt x startLine startCol
-- 
-- export
-- parseIdl : IdlGrammar a -> String -> Either Err a
-- parseIdl g s = do ts <- mapFst LexErr (lexIdlNoNoise s)
--                   (res,Nil) <- mapFst (toParseErr . head) (parse g ts)
--                     | (_,b :: _) => Left (NoEOI b)
--                   pure res
